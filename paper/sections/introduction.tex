A fundamental shift is occurring, beginning with the advent of the General Purpose Graphics Processing Unit (GPGPU) capable of much more processing than simply generating scenes for video games. This unit can handle specific workloads much more efficiently than a general CPU. While these workloads are specialized, in the increasingly parallel computing environments of today, it is finding much more use. However, it has been hampered by the large cost of moving massive amounts of data from the CPU onto the GPGPU's memory. To help bring the GPGPU to its fullest potential, it is getting swept into the CPU's increasing core count, joining the general cores on the CPU itself. 

This shift comes with its own history spawning from GUI creators trying to solve their own unique problem to big data researchers realizing the similarities their problems have. As the GPU evolved, its creators were inadvertently (or perhaps, intentionally) creating another general purpose processing unit that put the much more complicated CPU to shame on certain classes of problems. 

Merging the GPGPU into the CPU and creating a heterogenous architecture solves a performance problem as well as a power problem. Computers have advanced in performance much faster than the advancements in cooling. This is resulting in a condition called the power wall. One of the largest users of energy and heat in a system is a high performance graphics card. The card itself can be thought of as a small computer complete with a computing core and huge amounts of memory. Moving the GPGPU onto the CPU chip will eliminate the extra energy and help integrate it into the cooling infrastructure of the CPU. It will also allow the GPGPU to utilize the memory already included in the system reducing power and cooling as well. This will also help eliminate duplicate entries in the cache that need to be transferred down to the GPGPU.

This shift does not come without its own unique challenges. The GPGPU's single instruction multiple data (SIMD) class of computing differs wildly from the CPU's single instruction single data (SISD) class. This paper found that the differences can be classified into the following aspects: Control Flow, Memory Access, and Data Transfer. This paper will analyze all three differences, and synthesize a solution to one of the major problems hampering the merge.

